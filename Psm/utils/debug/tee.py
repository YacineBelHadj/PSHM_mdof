"""This file implements a helper class Tee, which copies a std stream
(stdout or stderr by choice) to a file while keeping things printed
on console at the same time.

"""

import os
import sys
from typing import Literal, Tuple

from ..python_utils.get_unique_new_file_path import get_unique_new_file_path


class Tee:
    """Initialize a Tee class for copying the stdout/stderr to a file
    with the given path, while maintaining the old stdout/stderr (e.g.
    printing output over terminal, etc.)

    Note that there are some drawbacks to this approach. For example,
    it only redirect the output generated by `print` and
    `sys.stdout.write`. Output genreatd by C/Fortran wrapped in Python will
    not be redirected. Also it has some strange interaction with Pytorch
    Lightning. Specifically, if you use `Trainer` with validation datasets,
    along with `Tee`, the script will not exit correctly. However, this does
    not affect the training process and results in any way.

    Examples:
        >>> import sys
        ... tee = Tee("stdout", "path/to/log.txt")

    Args:
        stream: The std stream to be copied ('stdout' or 'stderr').
        log_path: The path to the Tee log, the parent folder will be
            created upon initialization.

    """

    def __init__(
        self,
        stream: Literal["stdout", "stderr"],
        log_path: str,
    ):
        self.stream_literal = stream
        if stream == "stdout":
            self._stream = sys.stdout
            sys.stdout = self
        elif stream == "stderr":
            self._stream = sys.stderr
            sys.stderr = self
        else:
            _error_msg = "Stream must be either 'stdout' or 'stderr'."
            raise ValueError(_error_msg)
        _log_path = os.path.abspath(log_path)
        os.makedirs(os.path.dirname(_log_path), exist_ok=True)
        self._log_file_handle = open(_log_path, mode="a")

    def close(self):
        if self.stream_literal == "stdout":
            sys.stdout = self._stream
        elif self.stream_literal == "stderr":
            sys.stderr = self._stream
        self._log_file_handle.close()

    def flush(self):
        self._stream.flush()
        self._log_file_handle.flush()
        os.fsync(self._log_file_handle.fileno())

    def write(self, message: str):
        self._stream.write(message)
        self._log_file_handle.write(message)

    def __del__(self):
        self.close()

    def __enter__(self):
        pass

    def __exit__(self, *args):
        self.close()


def tee_output(
    log_dir_path: str,
    unique_file_name: bool = True,
) -> Tuple[Tee, Tee]:
    """Tee the stdout and stderr to the given log directory."""
    _stdout_log_file_path = (
        get_unique_new_file_path(os.path.join(log_dir_path, "stdout.txt"))
        if unique_file_name
        else os.path.join(log_dir_path, "stdout.txt")
    )
    _stderr_log_file_path = (
        get_unique_new_file_path(os.path.join(log_dir_path, "stderr.txt"))
        if unique_file_name
        else os.path.join(log_dir_path, "stderr.txt")
    )
    _stdout_tee = Tee(
        "stdout",
        _stdout_log_file_path,
    )
    _stderr_tee = Tee(
        "stderr",
        _stderr_log_file_path,
    )
    return _stdout_tee, _stderr_tee
